// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.2 (swiftlang-6.0.2.1.2 clang-1600.0.26.4)
// swift-module-flags: -target arm64-apple-watchos6.0 -enable-objc-interop -enable-library-evolution -swift-version 6 -enforce-exclusivity=checked -O -module-name OneEntry
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
public struct EmptyState : Swift.Codable, Swift.Sendable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias EmptyStateUser = OneEntry.User<OneEntry.EmptyState>
public struct User<State> : Swift.Identifiable, Swift.Sendable, Swift.Decodable where State : Swift.Decodable, State : Swift.Sendable {
  public let id: Swift.Int
  public let identifier: Swift.String
  public let formIdentifier: Swift.String
  public let authProviderIdentifier: Swift.String
  public let groups: [Swift.String]
  public let formData: OneEntry.LocalizedFormDataCollection
  public let state: State
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class OneEntryTokenCredential : OneEntry.Credential {
  public init(token: Swift.String)
  @objc deinit
}
public struct OneEntryImage : Swift.Codable, Swift.Sendable {
  public let size: Swift.Int
  public let filename: Swift.String
  public let previewLink: Swift.String
  public let downloadLink: Foundation.URL
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@dynamicMemberLookup public struct LocalizedInfoCollection {
  public typealias CollectionType = [Swift.String : OneEntry.LocalizeInfo]
  public init(collection: OneEntry.LocalizedInfoCollection.CollectionType)
  public init()
  public subscript(dynamicMember locale: Swift.String) -> OneEntry.LocalizeInfo? {
    get
  }
  public subscript(locale: Swift.String) -> OneEntry.LocalizeInfo? {
    get
  }
  public typealias Element = Swift.Dictionary<Swift.String, OneEntry.LocalizeInfo>.Element
  public typealias Index = Swift.Dictionary<Swift.String, OneEntry.LocalizeInfo>.Index
  public typealias Indices = Swift.DefaultIndices<OneEntry.LocalizedInfoCollection>
  public typealias Iterator = Swift.IndexingIterator<OneEntry.LocalizedInfoCollection>
  public typealias SubSequence = Swift.Slice<OneEntry.LocalizedInfoCollection>
}
public protocol LocalizeContent {
  var localizeInfos: OneEntry.LocalizedInfoCollection? { get }
  var attributeValues: OneEntry.LocalizedAttributeCollection? { get }
}
extension OneEntry.LocalizeContent {
  @available(*, deprecated, message: "This method is outdated, use subscript[dynamicMember: String] instead")
  public func localizeAttribute(_ marker: Swift.String, languageCode: Swift.String) -> OneEntry.OneEntryAttribute?
  @available(*, deprecated, message: "This method is outdated, use subscript[dynamicMember: String] instead")
  public func localizeInfo(languageCode: Swift.String) -> OneEntry.LocalizeInfo?
  public var localizeInfos: OneEntry.LocalizedInfoCollection? {
    get
  }
  public var attributeValues: OneEntry.LocalizedAttributeCollection? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class EventsService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.EventsService
  @objc deinit
}
extension OneEntry.EventsService {
  final public func registerForPushNotifications(fcm token: Swift.String)
  final public func setFCMToken(_ token: Swift.String) async throws
  final public func deleteFCMToken(_ token: Swift.String) async throws
  final public func subscribe(event marker: Swift.String, product id: Swift.Int, locale: Swift.String = "en_US", threshold: Swift.Double? = nil) async throws
  final public func unsubscribe(event marker: Swift.String, product id: Swift.Int, locale: Swift.String = "en_US", threshold: Swift.Double? = nil) async throws
  final public var notifications: _Concurrency.AsyncStream<OneEntry.ProductNotification> {
    get
  }
}
public struct OneEntryLocale : Swift.Identifiable, Swift.Decodable, Swift.Sendable {
  public let id: Swift.Int
  public let shortCode: Swift.String
  public let code: Swift.String
  public let name: Swift.String
  public let nativeName: Swift.String
  public let isActive: Swift.Bool
  public let image: Swift.String?
  public let position: Swift.Int?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryBlock : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent, Swift.Sendable {
  public var id: Swift.Int
  public var identifier: Swift.String
  public var position: Swift.Int
  public var type: Swift.String
  public var templateIdentifier: Swift.String?
  public var productPageUrls: [Swift.String]?
  public var localizeInfos: OneEntry.LocalizedInfoCollection?
  public var attributeValues: OneEntry.LocalizedAttributeCollection?
  public var products: [OneEntry.OneEntryProduct]?
  public var customSettings: OneEntry.OneEntryBlock.CustomSettings
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OneEntryBlock {
  public struct CustomSettings : Swift.Decodable, Swift.Sendable {
    public var condition: OneEntry.OneEntryBlock.CustomSettings.Condition
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension OneEntry.OneEntryBlock.CustomSettings {
  public struct Condition : Swift.Decodable, Swift.Sendable {
    public var ids: [Swift.Int]?
    public var name: Swift.String?
    public init(from decoder: any Swift.Decoder) throws
  }
}
public protocol OrderDataType : Swift.Sendable {
  var formData: [OneEntry.FormData] { get }
  var products: [OneEntry.OrderProduct] { get }
}
extension OneEntry.OrderDataType {
  public var formData: [OneEntry.FormData] {
    get
  }
  public var products: [OneEntry.OrderProduct] {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AuthService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.AuthService
  final public var accessToken: Swift.String? {
    get
  }
  final public var refreshToken: Swift.String? {
    get
  }
  final public var marker: Swift.String? {
    get
  }
  @objc deinit
}
extension OneEntry.AuthService {
  final public var isAuthorized: Swift.Bool {
    get
  }
  final public var user: OneEntry.EmptyStateUser {
    get async throws
  }
  final public func user<State>(state type: State.Type = EmptyState.self) async throws -> OneEntry.User<State> where State : Swift.Decodable, State : Swift.Sendable
  @discardableResult
  final public func changeUser<State>(form identifier: Swift.String, langCode: Swift.String, type: State.Type = EmptyState.self, state: State? = nil, @OneEntry.ResultBuilder<any OneEntry.AuthDataType> data: @_Concurrency.MainActor @Sendable () -> [any OneEntry.AuthDataType] = { [] }) async throws -> Swift.Bool where State : Swift.Encodable
  @discardableResult
  final public func changePassword(user identifier: Swift.String, code: Swift.String, password: Swift.String, confirmation: Swift.String, with marker: Swift.String) async throws -> Swift.Bool
  @discardableResult
  final public func subscribeToRemoteNotifications(device identifier: Swift.String) async throws -> Swift.Bool
  @discardableResult
  final public func unsubscribeFromRemoteNotifications(device identifier: Swift.String) async throws -> Swift.Bool
  @discardableResult
  final public func auth(_ marker: Swift.String, @OneEntry.ResultBuilder<OneEntry.AuthData> data: @_Concurrency.MainActor @Sendable () -> [OneEntry.AuthData]) async throws -> OneEntry.UserTokenType
  @discardableResult
  final public func signUp(marker: Swift.String, form identifier: Swift.String, langCode: Swift.String, @OneEntry.AuthBuilder data: @_Concurrency.MainActor @Sendable () -> [any OneEntry.AuthDataType]) async throws -> OneEntry.CreatedUserDto
  @discardableResult
  final public func activate(user identifier: Swift.String, code: Swift.String, with marker: Swift.String) async throws -> Swift.Bool
  @discardableResult
  final public func logout() async throws -> Swift.Bool
  @available(*, deprecated, message: "Use refresh(refresh token: String) instead")
  @discardableResult
  final public func refresh(refresh token: Swift.String, marker: Swift.String) async throws -> OneEntry.UserTokenType
  final public func generateCode(_ user: Swift.String, event: Swift.String, with marker: Swift.String) async throws
  @discardableResult
  final public func check(_ user: Swift.String, code: Swift.String, with marker: Swift.String) async throws -> Swift.Bool
  final public func providers(offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> [OneEntry.AuthProvider]
  final public func provider(with marker: Swift.String, langCode: Swift.String) async throws -> OneEntry.AuthProvider
}
public struct FormDataContainer : OneEntry.AuthDataType, OneEntry.OrderDataType {
  public var formData: [OneEntry.FormData]
  public init(@OneEntry.ResultBuilder<OneEntry.FormData> data: () -> [OneEntry.FormData])
}
public struct UserTokenType : Swift.Decodable, Swift.Sendable {
  public let userIdentifier: Swift.String
  public let authProviderIdentifier: Swift.String
  public let accessToken: Swift.String
  public let refreshToken: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct PaymentsConnected : Swift.Codable, Swift.Sendable {
  public var stripeAccountId: Swift.String
  public var stripePublishableKey: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Order : Swift.Codable, Swift.Sendable, Swift.Identifiable {
  public let id: Swift.Int
  public let statusIdentifier: Swift.String
  public let formIdentifier: Swift.String
  public let formData: OneEntry.FormDataCollection
  public let products: [OneEntry.Order.Product]
  public let totalSum: Swift.String
  public let currency: Swift.String
  public let createdDate: Swift.String
  public let paymentAccountIdentifier: Swift.String
  public let paymentAccountLocalizeInfos: OneEntry.LocalizedInfoCollection
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.Order {
  public struct Product : Swift.Codable, Swift.Sendable, Swift.Identifiable {
    public let id: Swift.Int
    public let title: Swift.String
    public let sku: Swift.String?
    public let price: Swift.Double
    public let quantity: Swift.Int
    public let previewImage: [OneEntry.OneEntryImage]?
    public typealias ID = Swift.Int
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
public struct OneEntryTextWithHeader : Swift.Identifiable, Swift.Codable, Swift.Sendable {
  public var id: Foundation.UUID {
    get
  }
  public let index: Foundation.UUID
  public let header: Swift.String
  public let htmlValue: Swift.String
  public let plainValue: Swift.String
  public typealias ID = Foundation.UUID
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class OneEntryCore : @unchecked Swift.Sendable {
  @objc deinit
}
extension OneEntry.OneEntryCore {
  public static func initializeApp(_ domain: Swift.String, credentials: OneEntry.Credential)
  public static func reset()
}
public protocol AuthDataType : Swift.Sendable {
  var authData: [OneEntry.AuthData] { get }
  var formData: [OneEntry.FormData] { get }
  var notification: OneEntry.NotificationData? { get }
}
extension OneEntry.AuthDataType {
  public var authData: [OneEntry.AuthData] {
    get
  }
  public var formData: [OneEntry.FormData] {
    get
  }
  public var notification: OneEntry.NotificationData? {
    get
  }
}
@_hasMissingDesignatedInitializers @_functionBuilder final public class ResultBuilder<Result> {
  public static func buildBlock(_ components: [Result]...) -> [Result]
  public static func buildEither(first component: [Result]) -> [Result]
  public static func buildEither(second component: [Result]) -> [Result]
  public static func buildOptional(_ component: [Result]?) -> [Result]
  public static func buildArray(_ components: [[Result]]) -> [Result]
  public static func buildExpression(_ expression: Result) -> [Result]
  @objc deinit
}
public struct PaymentSession : Swift.Codable, Swift.Sendable {
  public let id: Swift.Int
  public let updatedDate: Swift.String
  public let type: OneEntry.PaymentSession.SessionType
  public let status: OneEntry.PaymentSession.PaymentStatus
  public let orderId: Swift.Int
  public let paymentAccountId: Swift.Int
  public let paymentUrl: Swift.String?
  public let clientSecret: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.PaymentSession {
  public enum SessionType : Swift.String, Swift.Codable, Swift.Sendable {
    case session
    case intent
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum PaymentStatus : Swift.String, Swift.Codable, Swift.Sendable {
    case waiting
    case completed
    case canceled
    case expired
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public struct OneEntryPage : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent, Swift.Sendable {
  public let id: Swift.Int
  public var parentId: Swift.Int?
  public let pageUrl: Swift.String
  public let depth: Swift.Int?
  public let isVisible: Swift.Bool?
  public let position: Swift.Int?
  public let type: Swift.String?
  public let templateIdentifier: Swift.String?
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public let attributeValues: OneEntry.LocalizedAttributeCollection?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryMenuPage : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent, OneEntry.Treelike, Swift.Sendable {
  public let id: Swift.Int
  public var parentId: Swift.Int?
  public let pageUrl: Swift.String
  public let position: Swift.Int
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public var children: [OneEntry.OneEntryMenuPage]?
  public var attributeValues: OneEntry.LocalizedAttributeCollection?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntrySearchPage : Swift.Identifiable, Swift.Decodable, Swift.Sendable {
  public let id: Swift.Int
  public let title: Swift.String
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct AuthDataContainer : OneEntry.AuthDataType {
  public var authData: [OneEntry.AuthData]
  public init(@OneEntry.ResultBuilder<OneEntry.AuthData> data: () -> [OneEntry.AuthData])
}
public struct OrderProduct : Swift.Codable, Swift.Sendable, Swift.Hashable {
  public var productId: Swift.Int
  public var quantity: Swift.Int
  public init(id: Swift.Int, quantity: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: OneEntry.OrderProduct, b: OneEntry.OrderProduct) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OrderProduct : Swift.Identifiable {
  public var id: Swift.Int {
    get
  }
  public typealias ID = Swift.Int
}
public struct OneEntryFilter : Swift.Encodable, Swift.Sendable {
  public let attributeMarker: Swift.String
  public let conditionMarker: OneEntry.ConditionMarker
  public let conditionValue: (any Swift.Encodable & Swift.Sendable)
  public let pageUrls: [Swift.String]
  public init(attributeMarker: Swift.String, conditionMarker: OneEntry.ConditionMarker, conditionValue: some (Encodable & Sendable), pageUrls: [Swift.String] = [])
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct OneEntryResult<T> : Swift.Decodable, Swift.Sendable where T : Swift.Decodable, T : Swift.Sendable {
  public var items: [T]
  public var total: Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers public class Credential {
  @objc deinit
}
public struct ContentOrderStorage : Swift.Identifiable, Swift.Codable, OneEntry.LocalizeContent {
  public let id: Swift.Int
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public let identifier: Swift.String
  public let generalTypeId: Swift.Int
  public let formIdentifier: Swift.String
  public let paymentAccountIdentifiers: [OneEntry.ContentOrderStorage.PaymentAccountIdentifier]
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.ContentOrderStorage {
  public struct PaymentAccountIdentifier : Swift.Codable {
    public let identifier: Swift.String
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
public struct OneEntryGeneralType : Swift.Identifiable, Swift.Decodable {
  public let id: Swift.Int
  public let type: Swift.String
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryText : Swift.Codable, Swift.Sendable {
  public let htmlValue: Swift.String
  public let plainValue: Swift.String
  public init(html: Swift.String, plain: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryAdmin : Swift.Identifiable, Swift.Decodable {
  public let id: Swift.Int
  public let identifier: Swift.String
  public let position: Swift.Int?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
@dynamicMemberLookup public struct LocalizedFormDataCollection {
  public typealias CollectionType = [Swift.String : OneEntry.FormDataCollection]
  public init(collection: OneEntry.LocalizedFormDataCollection.CollectionType)
  public subscript(dynamicMember member: Swift.String) -> OneEntry.FormDataCollection {
    get
  }
  public typealias Element = Swift.Dictionary<Swift.String, OneEntry.FormDataCollection>.Element
  public typealias Index = Swift.Dictionary<Swift.String, OneEntry.FormDataCollection>.Index
  public typealias Indices = Swift.DefaultIndices<OneEntry.LocalizedFormDataCollection>
  public typealias Iterator = Swift.IndexingIterator<OneEntry.LocalizedFormDataCollection>
  public typealias SubSequence = Swift.Slice<OneEntry.LocalizedFormDataCollection>
}
extension OneEntry.LocalizedFormDataCollection : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.String
  public typealias Value = [OneEntry.FormData]
  public init(dictionaryLiteral elements: (Swift.String, [OneEntry.FormData])...)
}
public struct OneEntryProduct : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent, Swift.Sendable {
  public let id: Swift.Int
  public let price: Swift.Double?
  public let statusIdentifier: Swift.String?
  public let statusLocalizeInfos: OneEntry.LocalizedInfoCollection?
  public let sku: Swift.String?
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public let relatedIds: [Swift.Int]?
  public let templateIdentifier: Swift.String?
  public let attributeValues: OneEntry.LocalizedAttributeCollection?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntrySearchProduct : Swift.Identifiable, Swift.Decodable, Swift.Sendable {
  public let id: Swift.Int
  public let title: Swift.String
  public let pageId: Swift.Int
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class AttributesService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.AttributesService
  final public func attributes(from set: Swift.String, langCode: Swift.String) async throws -> [OneEntry.AttributeSet]
  final public func attribute(with marker: Swift.String, from set: Swift.String, langCode: Swift.String) async throws -> OneEntry.AttributeSet
  @objc deinit
}
public struct CreatedOrderDto : Swift.Decodable, Swift.Identifiable, Swift.Sendable {
  public let id: Swift.Int
  public let formIdentifier: Swift.String
  public let paymentAccountIdentifier: Swift.String
  public let statusIdentifier: Swift.String?
  public let formData: OneEntry.LocalizedFormDataCollection
  public let products: [OneEntry.OrderProduct]
  public let createdDate: Swift.String?
  public let currency: Swift.String
  public let totalSum: Swift.Double?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public enum SortDirection : Swift.String, Swift.Decodable, Swift.Sendable {
  case desk
  case asc
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CreatedUserDto : Swift.Codable, Swift.Sendable {
  public let id: Swift.Int
  public let updatedDate: Swift.String
  public let version: Swift.Int
  public let identifier: Swift.String
  public let isActive: Swift.Bool
  public let authProviderId: Swift.Int?
  public let formData: [Swift.String : [OneEntry.FormData]]
  public let notificationData: OneEntry.NotificationData?
  public let locale: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryFile : Swift.Codable, Swift.Sendable {
  public let filename: Swift.String
  public let downloadLink: Swift.String
  public let size: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OneEntryFile {
  public var url: Foundation.URL? {
    get
  }
}
public struct OneEntryForm : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent, Swift.Sendable {
  public let id: Swift.Int
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public let identifier: Swift.String
  public let attributes: [OneEntry.FormAttribute]
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct FormAttribute : Swift.Decodable, Swift.Sendable {
  public let type: Swift.String
  public let marker: Swift.String
  public let isVisible: Swift.Bool
  public var localizeInfos: OneEntry.LocalizeInfo
  public var settings: OneEntry.FormAttribute.Settings
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.FormAttribute {
  public struct Settings : Swift.Decodable, Swift.Sendable {
    public var captchaKey: Swift.String?
    public var captchaKeyName: Swift.String?
    public var captchaKeyDomain: Swift.String?
    public init(from decoder: any Swift.Decoder) throws
  }
}
public struct OneEntryPageConfig : Swift.Decodable {
  public let rowsPerPage: Swift.Int?
  public let productsPerRow: Swift.Int?
  public init(from decoder: any Swift.Decoder) throws
}
public protocol Treelike : Swift.Identifiable {
  var parentId: Swift.Int? { get set }
  var children: [Self]? { get set }
  func toNode() -> OneEntry.Node<Self>
}
extension OneEntry.Treelike {
  public func toNode() -> OneEntry.Node<Self>
}
public class Node<T> where T : OneEntry.Treelike {
  public init(item: T)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class OneEntryTree<T> where T : OneEntry.Treelike {
  @objc deinit
}
#if compiler(>=5.3) && $RetroactiveAttribute
extension CoreFoundation.CFString : @unchecked @retroactive Swift.Sendable {
}
#else
extension CoreFoundation.CFString : @unchecked Swift.Sendable {
}
#endif
public enum KeychainItemAccessibility : Swift.Sendable {
  @available(iOS 4, *)
  case afterFirstUnlock
  @available(iOS 4, *)
  case afterFirstUnlockThisDeviceOnly
  @available(iOS 4, *)
  case always
  @available(iOS 8, *)
  case whenPasscodeSetThisDeviceOnly
  @available(iOS 4, *)
  case alwaysThisDeviceOnly
  @available(iOS 4, *)
  case whenUnlocked
  @available(iOS 4, *)
  case whenUnlockedThisDeviceOnly
  public static func == (a: OneEntry.KeychainItemAccessibility, b: OneEntry.KeychainItemAccessibility) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct ProductNotification : Swift.Decodable, Swift.Sendable {
  public var message: Swift.String
  public var attributes: OneEntry.AttributeCollection
  public var product: OneEntry.ProductNotification.Product
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.ProductNotification {
  public struct Product : Swift.Identifiable, Swift.Decodable, Swift.Sendable {
    public var id: Swift.Int
    public var status: OneEntry.ProductNotification.Product.Status
    public var info: OneEntry.LocalizeInfo
    public var attributes: OneEntry.AttributeCollection
    public typealias ID = Swift.Int
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension OneEntry.ProductNotification.Product {
  public struct Status : Swift.Decodable, Swift.Sendable {
    public var identifier: Swift.String
    public var info: OneEntry.LocalizeInfo
    public init(from decoder: any Swift.Decoder) throws
  }
}
public struct LocalizeInfo : Swift.Codable, Swift.Sendable {
  public let title: Swift.String?
  public let content: OneEntry.InfoContent?
  public let menuTitle: Swift.String?
  public let htmlContent: Swift.String?
  public let plainContent: Swift.String?
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct InfoContent : Swift.Codable, Swift.Sendable {
  public let value: Swift.String
  public let isEditorDisabled: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@dynamicMemberLookup public struct LocalizedAttributeCollection {
  public typealias CollectionType = [Swift.String : OneEntry.AttributeCollection]
  public init(collection: OneEntry.LocalizedAttributeCollection.CollectionType)
  public init()
  public subscript(dynamicMember member: Swift.String) -> OneEntry.LocalizedAttributeCollection.CollectionType.Value {
    get
  }
  public subscript(locale: Swift.String) -> OneEntry.LocalizedAttributeCollection.CollectionType.Value {
    get
  }
  public typealias Element = Swift.Dictionary<Swift.String, OneEntry.AttributeCollection>.Element
  public typealias Index = Swift.Dictionary<Swift.String, OneEntry.AttributeCollection>.Index
  public typealias Indices = Swift.DefaultIndices<OneEntry.LocalizedAttributeCollection>
  public typealias Iterator = Swift.IndexingIterator<OneEntry.LocalizedAttributeCollection>
  public typealias SubSequence = Swift.Slice<OneEntry.LocalizedAttributeCollection>
}
@_hasMissingDesignatedInitializers final public class OneEntryCertificateCredential : OneEntry.Credential {
  public init(name: Swift.String, password: Swift.String? = nil, bundle: Foundation.Bundle = .main)
  @objc deinit
}
extension OneEntry.OneEntryCertificateCredential {
  public enum OneEntryCredentialError : Foundation.LocalizedError {
    case certificateImportFailed(Darwin.OSStatus)
    case certificateNotFound(Swift.String)
    case credentialExtractFailed
    public var errorDescription: Swift.String? {
      get
    }
  }
}
public enum ConditionMarker : Swift.String, Swift.Codable, Swift.Sendable {
  case `in`
  case nin
  case eq
  case neq
  case mth
  case lth
  case exs
  case nexs
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct OneEntryAttribute : Swift.Sendable {
  public var type: Swift.String
  public var value: (any Swift.Codable & Swift.Sendable)?
}
extension OneEntry.OneEntryAttribute : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OneEntryAttribute : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OneEntry.OneEntryAttribute {
  public var stringValue: Swift.String? {
    get
  }
  public var imageValues: [OneEntry.OneEntryImage]? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var intValue: Swift.Int? {
    get
  }
  public var dateValue: OneEntry.OneEntryDate? {
    get
  }
  public var textWithHeaderValues: [OneEntry.OneEntryTextWithHeader]? {
    get
  }
  public var textValues: [OneEntry.OneEntryText]? {
    get
  }
  public var fileValues: [OneEntry.OneEntryFile]? {
    get
  }
  public var listValues: [OneEntry.OneEntryList]? {
    get
  }
}
public struct PaymentAccount : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent, Swift.Sendable {
  public let id: Swift.Int
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public let identifier: Swift.String
  public let type: Swift.String
  public let isVisible: Swift.Bool
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryError : Swift.Decodable, Swift.Sendable {
  public var statusCode: Swift.Int?
  public var message: Swift.String
  public var pageData: OneEntry.OneEntryPage?
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OneEntryError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers @_functionBuilder final public class AuthBuilder {
  public static func buildBlock(_ auth: OneEntry.AuthDataContainer, _ components: any OneEntry.AuthDataType...) -> [any OneEntry.AuthDataType]
  @available(*, unavailable, message: "AuthDataContainer must be present when building authentication data")
  public static func buildBlock(_ components: any OneEntry.AuthDataType...) -> [any OneEntry.AuthDataType]
  @objc deinit
}
public struct AuthData : Swift.Sendable, Swift.Codable {
  public var marker: Swift.String
  public var value: Swift.String
  public init(marker: Swift.String, value: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ExtendedValue : Swift.Sendable {
}
extension OneEntry.ExtendedValue : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.ExtendedValue {
  public var stringValue: Swift.String? {
    get
  }
  public var imageValue: OneEntry.OneEntryImage? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var intValue: Swift.Int? {
    get
  }
  public var dateValue: OneEntry.OneEntryDate? {
    get
  }
  public var fileValue: OneEntry.OneEntryFile? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class OrdersService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.OrdersService
  @objc deinit
}
extension OneEntry.OrdersService {
  final public func create(storage: Swift.String, form identifier: Swift.String, payment account: Swift.String, status: Swift.String? = nil, langCode: Swift.String, @OneEntry.ResultBuilder<any OneEntry.OrderDataType> data: @_Concurrency.MainActor @Sendable () -> [any OneEntry.OrderDataType]) async throws -> OneEntry.CreatedOrderDto
  @discardableResult
  final public func update(order id: Swift.Int, storage: Swift.String, form identifier: Swift.String, payment account: Swift.String, langCode: Swift.String, @OneEntry.ResultBuilder<any OneEntry.OrderDataType> data: @_Concurrency.MainActor @Sendable () -> [any OneEntry.OrderDataType]) async throws -> OneEntry.CreatedOrderDto
  final public func orders(storage: Swift.String, offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> OneEntry.OneEntryResult<OneEntry.Order>
  final public func storages(offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> [OneEntry.ContentOrderStorage]
  final public func storage(with marker: Swift.String, langCode: Swift.String) async throws -> OneEntry.ContentOrderStorage
}
public struct AttributeSet : Swift.Decodable, Swift.Sendable {
  public let type: Swift.String
  public let marker: Swift.String
  public let position: Swift.Int
  public let listTitles: [OneEntry.OneEntryList]
  public let localizeInfos: OneEntry.LocalizeInfo?
  public init(from decoder: any Swift.Decoder) throws
}
public enum AuthError : Swift.String, Foundation.LocalizedError {
  case userTokenNotFound
  public var errorDescription: Swift.String? {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct OneEntryTemplate : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent {
  public let id: Swift.Int
  public let identifier: Swift.String
  public let generalTypeId: Swift.Int
  public let generalTypeName: Swift.String
  public let position: Swift.Int?
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryAllTemplates : Swift.Decodable {
  public let asDictionary: [Swift.String : [OneEntry.OneEntryTemplate]]
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OneEntryAllTemplates {
  public var forCatalogProducts: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forBasketPage: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forErrorPage: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forCatalogPages: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forProductPreview: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forProductPage: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forSimilarProductBlock: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forStatisticProductBlock: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forProductBlock: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forForm: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forFormField: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forNewsPage: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forNewsBlock: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forNewsPreview: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forOneNewsPage: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forUsualPage: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forTextBlock: [OneEntry.OneEntryTemplate] {
    get
  }
  public var forSliderBlock: [OneEntry.OneEntryTemplate] {
    get
  }
}
public struct OneEntryDate : Swift.Codable, Swift.Sendable {
  public var fullDate: Swift.String
  public var formatString: Swift.String
  public var formattedValue: Swift.String
  public init(fullDate: Swift.String, formatString: Swift.String, formattedValue: Swift.String)
  public init(_ date: Foundation.Date, format: Swift.String = "DD-MM-YYYY")
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OneEntryDate {
  public var date: Foundation.Date? {
    get
  }
  public func formatted(format: Swift.String = "yyyy-MM-dd'T'HH:mm:ss.SSSZ") -> Foundation.Date?
}
public struct NotificationData : Swift.Codable, Swift.Sendable {
  public var email: Swift.String
  public var phonePush: [Swift.String]
  public var phoneSMS: Swift.String
  public init(email: Swift.String, phonePush: [Swift.String], phoneSMS: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.NotificationData : OneEntry.AuthDataType {
  public var notification: OneEntry.NotificationData? {
    get
  }
}
public struct ProductsContainer : OneEntry.OrderDataType {
  public var products: [OneEntry.OrderProduct]
  public init(@OneEntry.ResultBuilder<OneEntry.OrderProduct> products: () -> [OneEntry.OrderProduct])
  public init(_ products: [OneEntry.OrderProduct])
}
public struct OneEntryFormDataRequest : Swift.Encodable, Swift.Sendable {
  public let formIdentifier: Swift.String
  public let formData: OneEntry.LocalizedFormDataCollection
  public init(formIdentifier: Swift.String, formData: OneEntry.LocalizedFormDataCollection)
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct OneEntryFormDataResponse : Swift.Identifiable, Swift.Decodable, Swift.Sendable {
  public let id: Swift.Int
  public let time: Swift.String
  public let formIdentifier: Swift.String
  public let formData: OneEntry.LocalizedFormDataCollection
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryTemplatePreview : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent {
  public let id: Swift.Int
  public let version: Swift.Int?
  public let identifier: Swift.String
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryProportion : Swift.Decodable {
  public let width: Swift.Double?
  public let height: Swift.Double?
  public let side: Swift.Double?
  public let marker: Swift.String
  public let alignmentType: Swift.String
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryProductStatus : Swift.Identifiable, Swift.Decodable, OneEntry.LocalizeContent {
  public let id: Swift.Int
  public let updatedDate: Swift.String?
  public let version: Swift.Int
  public let identifier: Swift.String
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public typealias ID = Swift.Int
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.OneEntryProductStatus {
  public var markerValidation: Swift.Bool {
    get async throws
  }
}
public struct AuthProvider : Swift.Identifiable, Swift.Codable, OneEntry.LocalizeContent, Swift.Sendable {
  public let id: Swift.Int
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public let version: Swift.Int
  public let identifier: Swift.String
  public let isActive: Swift.Bool
  public let isCheckCode: Swift.Bool
  public let type: OneEntry.AuthProvider.ProviderType
  public let formIdentifier: Swift.String?
  public let config: OneEntry.UsersAuthProviderConfigType?
  public typealias ID = Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension OneEntry.AuthProvider {
  public enum ProviderType : Swift.String, Swift.Codable, Swift.Sendable {
    case email
    case phone
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public struct UsersAuthProviderConfigType : Swift.Codable, Swift.Sendable {
  public let deleteNoneActiveUsersAfterDays: Swift.Int
  public let systemCodeTlsSec: Swift.Int
  public let systemCodeLength: Swift.Int
  public let systemCodeOnlyNumbers: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OneEntry.UsersAuthProviderConfigType {
  public init(from decoder: any Swift.Decoder) throws
}
public struct OneEntryMenu : Swift.Identifiable, OneEntry.LocalizeContent {
  public let id: Swift.Int
  public let identifier: Swift.String
  public let localizeInfos: OneEntry.LocalizedInfoCollection?
  public var pages: [OneEntry.OneEntryMenuPage]
  public typealias ID = Swift.Int
}
extension OneEntry.OneEntryMenu : Swift.Decodable, Swift.Sendable {
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers final public class PagesService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.PagesService
  final public func rootPages(langCode: Swift.String) async throws -> [OneEntry.OneEntryPage]
  final public func children(for pageURL: Swift.String, langCode: Swift.String) async throws -> [OneEntry.OneEntryPage]
  final public func catalogPages(langCode: Swift.String) async throws -> [OneEntry.OneEntryPage]
  final public func pages(langCode: Swift.String) async throws -> [OneEntry.OneEntryPage]
  final public func page(with id: Swift.Int, langCode: Swift.String) async throws -> OneEntry.OneEntryPage
  final public func page(with url: Swift.String, langCode: Swift.String) async throws -> OneEntry.OneEntryPage
  final public func config(with url: Swift.String) async throws -> OneEntry.OneEntryPageConfig
  final public func quickSearch(_ name: Swift.String, langCode: Swift.String) async throws -> [OneEntry.OneEntrySearchPage]
  final public func blocks(page url: Swift.String, langCode: Swift.String) async throws -> [OneEntry.OneEntryBlock]
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class TemplatesPreviewService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.TemplatesPreviewService
  final public var templates: [OneEntry.OneEntryTemplatePreview] {
    get async throws
  }
  final public func template(with id: Swift.Int) async throws -> OneEntry.OneEntryTemplatePreview
  final public func template(with marker: Swift.String) async throws -> OneEntry.OneEntryTemplatePreview
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ProjectService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.ProjectService
  final public var activeLocales: [OneEntry.OneEntryLocale] {
    get async throws
  }
  final public var admins: [OneEntry.OneEntryAdmin] {
    get async throws
  }
  final public var generalTypes: [OneEntry.OneEntryGeneralType] {
    get async throws
  }
  final public func test404() async throws
  final public func test500() async throws
  final public func menu(with marker: Swift.String, langCode: Swift.String) async throws -> OneEntry.OneEntryMenu
  final public func uploadFile(file url: Foundation.URL, type: Swift.String, entity: Swift.String, id: Swift.Int, width: Swift.Int? = nil, height: Swift.Int? = nil, compress: Swift.Bool = false) async throws -> [OneEntry.OneEntryFile]
  final public func file(name: Swift.String, type: Swift.String, entity: Swift.String, id: Swift.Int) async throws -> Foundation.Data
  final public func deleteFile(name: Swift.String, type: Swift.String, entity: Swift.String, id: Swift.Int) async throws
  @objc deinit
}
@dynamicMemberLookup public struct AttributeCollection {
  public typealias CollectionType = [Swift.String : OneEntry.OneEntryAttribute]
  public init(collection: OneEntry.AttributeCollection.CollectionType)
  public init()
  public subscript(dynamicMember member: Swift.String) -> OneEntry.AttributeCollection.CollectionType.Value? {
    get
  }
  public typealias Element = Swift.Dictionary<Swift.String, OneEntry.OneEntryAttribute>.Element
  public typealias Index = Swift.Dictionary<Swift.String, OneEntry.OneEntryAttribute>.Index
  public typealias Indices = Swift.DefaultIndices<OneEntry.AttributeCollection>
  public typealias Iterator = Swift.IndexingIterator<OneEntry.AttributeCollection>
  public typealias SubSequence = Swift.Slice<OneEntry.AttributeCollection>
}
@_hasMissingDesignatedInitializers final public class FormsService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.FormsService
  final public func forms(offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> [OneEntry.OneEntryForm]
  final public func form(with marker: Swift.String, langCode: Swift.String) async throws -> OneEntry.OneEntryForm
  @discardableResult
  final public func sendData(with identifier: Swift.String, locale: Swift.String, @OneEntry.ResultBuilder<OneEntry.FormData> data: @_Concurrency.MainActor @Sendable () -> [OneEntry.FormData]) async throws -> OneEntry.OneEntryFormDataResponse
  final public func fetchData(langCode: Swift.String, limit: Swift.Int = 30, offset: Swift.Int = 0) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryFormDataResponse>
  final public func data(with marker: Swift.String, offset: Swift.Int = 0, limit: Swift.Int = 30) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryFormDataResponse>
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CatalogService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.CatalogService
  final public func products(offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String, statusMarker: Swift.String? = nil, conditionValue: Swift.String? = nil, conditionMarker: OneEntry.ConditionMarker? = nil, attributeMarker: Swift.String? = nil, sortKey: Swift.String? = nil, sortOrder: OneEntry.SortDirection? = nil, @OneEntry.ResultBuilder<OneEntry.OneEntryFilter> filters: @_Concurrency.MainActor @Sendable () -> [OneEntry.OneEntryFilter] = { [] }) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func emptyPageProducts(offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String, sortKey: Swift.String? = nil, sortOrder: OneEntry.SortDirection? = nil) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func products(page id: Swift.Int, offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String, sortKey: Swift.String? = nil, sortOrder: OneEntry.SortDirection? = nil, @OneEntry.ResultBuilder<OneEntry.OneEntryFilter> filters: @_Concurrency.MainActor @Sendable () -> [OneEntry.OneEntryFilter] = { [] }) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func products(page url: Swift.String, offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String, sortKey: Swift.String? = nil, sortOrder: OneEntry.SortDirection? = nil, @OneEntry.ResultBuilder<OneEntry.OneEntryFilter> filters: @_Concurrency.MainActor @Sendable () -> [OneEntry.OneEntryFilter] = { [] }) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func relatedProducts(product id: Swift.Int, offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String, sortKey: Swift.String? = nil, sortOrder: OneEntry.SortDirection? = nil) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func product(with id: Swift.Int, langCode: Swift.String) async throws -> OneEntry.OneEntryProduct
  final public func blocks(for id: Swift.Int) async throws -> [OneEntry.OneEntryBlock]
  @available(*, deprecated, renamed: "products", message: "This method is outdated and will be replaced by products with the filters parameter")
  final public func filterProducts(offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String, sortOrder: OneEntry.SortDirection? = nil, sortKey: Swift.String? = nil, @OneEntry.ResultBuilder<OneEntry.OneEntryFilter> filters: @_Concurrency.MainActor @Sendable () -> [OneEntry.OneEntryFilter]) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func quickSearch(_ name: Swift.String, langCode: Swift.String) async throws -> [OneEntry.OneEntrySearchProduct]
  final public var productStatuses: [OneEntry.OneEntryProductStatus] {
    get async throws
  }
  final public func productStatus(with id: Swift.Int) async throws -> OneEntry.OneEntryProductStatus
  final public func productStatus(with marker: Swift.String) async throws -> OneEntry.OneEntryProductStatus
  final public func productStatusMarkerValidation(_ marker: Swift.String) async throws -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class BlocksService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.BlocksService
  final public func similarProducts(_ marker: Swift.String, offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func products(_ marker: Swift.String, offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryProduct>
  final public func blocks(offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> OneEntry.OneEntryResult<OneEntry.OneEntryBlock>
  final public func block(_ marker: Swift.String, offset: Swift.Int = 0, limit: Swift.Int = 30, langCode: Swift.String) async throws -> OneEntry.OneEntryBlock
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class TemplatesService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.TemplatesService
  final public var templates: OneEntry.OneEntryAllTemplates {
    get async throws
  }
  final public func templates(with type: Swift.String) async throws -> [OneEntry.OneEntryTemplate]
  @objc deinit
}
public enum AttributeType : Swift.String, Swift.CaseIterable, Swift.Decodable, Swift.Sendable, Swift.Hashable {
  case integer
  case date
  case file
  case list
  case real
  case spam
  case text
  case time
  case float
  case button
  case image
  case string
  case dateTime
  case textWithHeader
  case groupOfImages
  case radioButton
  case entity
  case unexpected
  public init?(rawValue: Swift.String)
  public typealias AllCases = [OneEntry.AttributeType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [OneEntry.AttributeType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct OneEntryList : Swift.Codable, Swift.Sendable {
  public let title: Swift.String
  public let value: Swift.String
  public let extended: OneEntry.ExtendedValue?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@dynamicMemberLookup public struct FormDataCollection {
  public typealias CollectionType = [OneEntry.FormData]
  public init(collection: OneEntry.FormDataCollection.CollectionType)
  public init()
  public subscript(dynamicMember member: Swift.String) -> OneEntry.FormData? {
    get
  }
  public typealias Element = OneEntry.FormData
  public typealias Index = Swift.Array<OneEntry.FormData>.Index
  public typealias Indices = Swift.DefaultIndices<OneEntry.FormDataCollection>
  public typealias Iterator = Swift.IndexingIterator<OneEntry.FormDataCollection>
  public typealias SubSequence = Swift.Slice<OneEntry.FormDataCollection>
}
extension OneEntry.FormDataCollection : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: OneEntry.FormDataCollection.Element...)
  public typealias ArrayLiteralElement = OneEntry.FormDataCollection.Element
}
@dynamicMemberLookup public struct FormData : Swift.Sendable {
  public var marker: Swift.String
  public var attribute: OneEntry.OneEntryAttribute
  public init(marker: Swift.String, value: Swift.String)
  public init<Element>(type: Swift.KeyPath<OneEntry.FormData.DataType, Element>, marker: Swift.String, value: Element) where Element : Swift.Decodable, Element : Swift.Encodable, Element : Swift.Sendable
}
extension OneEntry.FormData {
  public subscript<T>(dynamicMember keyPath: Swift.KeyPath<OneEntry.OneEntryAttribute, T>) -> T {
    get
  }
}
extension OneEntry.FormData : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension OneEntry.FormData {
  public struct DataType {
    public let integer: Swift.String
    public let date: OneEntry.OneEntryDate
    public let file: OneEntry.OneEntryFile
    public let list: [OneEntry.OneEntryList]
    public let real: Swift.String
    public let text: [OneEntry.OneEntryText]
    public let time: OneEntry.OneEntryDate
    public let float: Swift.String
    public let image: [OneEntry.OneEntryImage]
    public let string: Swift.String
    public let dateTime: OneEntry.OneEntryDate
    public let textWithHeader: OneEntry.OneEntryTextWithHeader
    public let groupOfImages: [OneEntry.OneEntryImage]
  }
}
@_hasMissingDesignatedInitializers final public actor PaymentService : @unchecked Swift.Sendable {
  public static let shared: OneEntry.PaymentService
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
extension OneEntry.PaymentService {
  final public func createSession(order id: Swift.Int, type: OneEntry.PaymentSession.SessionType, automaticTaxEnabled: Swift.Bool = true) async throws -> OneEntry.PaymentSession
  final public func sessions(limit: Swift.Int = 30, offset: Swift.Int = 0) async throws -> OneEntry.OneEntryResult<OneEntry.PaymentSession>
  final public func session(with id: Swift.Int) async throws -> OneEntry.PaymentSession
  final public var accounts: [OneEntry.PaymentAccount] {
    get async throws
  }
  final public func account(with id: Swift.Int) async throws -> OneEntry.PaymentAccount
  final public var connected: OneEntry.PaymentsConnected {
    get async throws
  }
}
extension OneEntry.LocalizedInfoCollection : Swift.Sendable {}
extension OneEntry.LocalizedInfoCollection : Swift.Encodable {}
extension OneEntry.LocalizedInfoCollection : Swift.Decodable {}
extension OneEntry.LocalizedInfoCollection : Swift.Collection {}
extension OneEntry.PaymentSession.SessionType : Swift.Equatable {}
extension OneEntry.PaymentSession.SessionType : Swift.Hashable {}
extension OneEntry.PaymentSession.SessionType : Swift.RawRepresentable {}
extension OneEntry.PaymentSession.PaymentStatus : Swift.Equatable {}
extension OneEntry.PaymentSession.PaymentStatus : Swift.Hashable {}
extension OneEntry.PaymentSession.PaymentStatus : Swift.RawRepresentable {}
extension OneEntry.LocalizedFormDataCollection : Swift.Sendable {}
extension OneEntry.LocalizedFormDataCollection : Swift.Encodable {}
extension OneEntry.LocalizedFormDataCollection : Swift.Decodable {}
extension OneEntry.LocalizedFormDataCollection : Swift.Collection {}
extension OneEntry.SortDirection : Swift.Equatable {}
extension OneEntry.SortDirection : Swift.Hashable {}
extension OneEntry.SortDirection : Swift.RawRepresentable {}
extension OneEntry.KeychainItemAccessibility : Swift.Equatable {}
extension OneEntry.KeychainItemAccessibility : Swift.Hashable {}
extension OneEntry.LocalizedAttributeCollection : Swift.Sendable {}
extension OneEntry.LocalizedAttributeCollection : Swift.Encodable {}
extension OneEntry.LocalizedAttributeCollection : Swift.Decodable {}
extension OneEntry.LocalizedAttributeCollection : Swift.Collection {}
extension OneEntry.ConditionMarker : Swift.Equatable {}
extension OneEntry.ConditionMarker : Swift.Hashable {}
extension OneEntry.ConditionMarker : Swift.RawRepresentable {}
extension OneEntry.AuthError : Swift.Equatable {}
extension OneEntry.AuthError : Swift.Hashable {}
extension OneEntry.AuthError : Swift.RawRepresentable {}
extension OneEntry.AuthProvider.ProviderType : Swift.Equatable {}
extension OneEntry.AuthProvider.ProviderType : Swift.Hashable {}
extension OneEntry.AuthProvider.ProviderType : Swift.RawRepresentable {}
extension OneEntry.AttributeCollection : Swift.Sendable {}
extension OneEntry.AttributeCollection : Swift.Encodable {}
extension OneEntry.AttributeCollection : Swift.Decodable {}
extension OneEntry.AttributeCollection : Swift.Collection {}
extension OneEntry.AttributeType : Swift.RawRepresentable {}
extension OneEntry.FormDataCollection : Swift.Sendable {}
extension OneEntry.FormDataCollection : Swift.Encodable {}
extension OneEntry.FormDataCollection : Swift.Decodable {}
extension OneEntry.FormDataCollection : Swift.Collection {}
